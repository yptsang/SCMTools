<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>52-Week Demand Forecasting Studio</title>

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>

    <!-- PapaParse for CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <!-- Math.js for Matrix operations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>

    <style>
        body {
            background-color: #f4f6f9;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .sidebar {
            background-color: #ffffff;
            border-right: 1px solid #dee2e6;
            height: 100vh;
            overflow-y: auto;
            padding: 20px;
            position: fixed;
            width: 340px;
            z-index: 1000;
        }
        .main-content {
            margin-left: 340px;
            padding: 20px;
        }
        .param-group {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            display: none;
        }
        .spinner-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .small-note {
            font-size: 0.85rem;
            color: #6c757d;
        }
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
                border-right: none;
                border-bottom: 1px solid #dee2e6;
            }
            .main-content {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>

<!-- Loading Spinner -->
<div class="spinner-overlay" id="loadingSpinner">
    <div class="text-center">
        <div class="spinner-border text-primary" role="status"></div>
        <p class="mt-2 fw-bold">Training & Forecasting...</p>
    </div>
</div>

<!-- Sidebar Controls -->
<div class="sidebar">
    <h4 class="mb-4 fw-bold text-primary">52-Week Forecasting Studio</h4>

    <!-- Data Section -->
    <div class="mb-4">
        <label class="form-label fw-bold">1. Data Source</label>
        <input type="file" class="form-control mb-2" id="csvUpload" accept=".csv">
        <button class="btn btn-outline-secondary btn-sm w-100" id="btnReset">Reset to Demo Data</button>
        <small class="text-muted d-block mt-1">
            Sample file: <strong>dfDataTry_v2.csv</strong>. Daily data are aggregated to weekly (Sun–Sat).
            Negative values are clipped to zero. Missing weeks are filled with 0.
        </small>
    </div>

    <!-- Column Selection -->
    <div class="mb-4" id="columnSelectionSection" style="display:none;">
        <label class="form-label fw-bold">2. Column Selection</label>
        <div class="small text-muted mb-2" id="columnHint">Auto-detect is enabled.</div>

        <label class="form-label small">Date Column</label>
        <select class="form-select form-select-sm mb-2" id="dateColSelect"></select>

        <label class="form-label small">Demand Column</label>
        <select class="form-select form-select-sm mb-2" id="valueColSelect"></select>

        <button class="btn btn-outline-primary btn-sm w-100" id="btnApplyColumns">Apply Columns</button>

        <div class="table-responsive mt-2">
            <table class="table table-sm table-bordered mb-0">
                <thead><tr id="previewHead"></tr></thead>
                <tbody id="previewBody"></tbody>
            </table>
        </div>
    </div>

    <!-- Mode Section -->
    <div class="mb-4">
        <label class="form-label fw-bold">3. Mode</label>
        <div class="form-check">
            <input class="form-check-input" type="radio" name="mode" id="modeValidate" value="validate" checked>
            <label class="form-check-label" for="modeValidate">Forecast + Validation</label>
        </div>
        <div class="form-check mb-2">
            <input class="form-check-input" type="radio" name="mode" id="modeForecast" value="forecast">
            <label class="form-check-label" for="modeForecast">Pure Forecast (Next 52 Weeks)</label>
        </div>
        <div class="small text-muted">Forecast horizon: <strong>52 weeks</strong></div>
    </div>

    <!-- Training Window -->
    <div class="mb-4" id="trainingWindowSection">
        <label class="form-label fw-bold">4. Training Window (Weekly)</label>
        <p class="small text-muted mb-1">Select historical range for model fitting.</p>
        <label class="form-label small">Start</label>
        <input type="range" class="form-range" id="trainStart" min="0" max="0" value="0">
        <label class="form-label small">End (Forecast starts after this week)</label>
        <input type="range" class="form-range" id="trainEnd" min="0" max="0" value="0">
        <div class="d-flex justify-content-between small">
            <span>Start: <span id="trainStartLabel">-</span></span>
            <span>End: <span id="trainEndLabel">-</span></span>
        </div>
        <div class="small text-muted mt-1">
            Holdout available: <span id="holdoutAvail">0</span> weeks (need 52 for metrics)
        </div>
    </div>

    <!-- Models Section -->
    <div class="mb-4">
        <label class="form-label fw-bold">5. Models (Select Multiple)</label>

        <div class="d-flex gap-2 mb-2">
            <button class="btn btn-outline-secondary btn-sm w-100" id="btnSelectAll">Select All</button>
            <button class="btn btn-outline-secondary btn-sm w-100" id="btnClearAll">Clear All</button>
        </div>

        <div class="form-check">
            <input class="form-check-input model-checkbox" type="checkbox" id="model-hw" value="hw" checked>
            <label class="form-check-label" for="model-hw">Holt‑Winters (Additive, 52w)</label>
        </div>
        <div id="params-hw" class="param-group">
            <label class="form-label small">Alpha (Level)</label>
            <input type="number" class="form-control form-control-sm mb-2" id="hw-alpha" value="0.3" step="0.05" min="0" max="1">
            <label class="form-label small">Beta (Trend)</label>
            <input type="number" class="form-control form-control-sm mb-2" id="hw-beta" value="0.1" step="0.05" min="0" max="1">
            <label class="form-label small">Gamma (Seasonal)</label>
            <input type="number" class="form-control form-control-sm" id="hw-gamma" value="0.2" step="0.05" min="0" max="1">
        </div>

        <div class="form-check">
            <input class="form-check-input model-checkbox" type="checkbox" id="model-fourier" value="fourier" checked>
            <label class="form-check-label" for="model-fourier">Seasonal Trend Regression (Fourier)</label>
        </div>
        <div id="params-fourier" class="param-group">
            <label class="form-label small">Fourier Pairs (K)</label>
            <input type="number" class="form-control form-control-sm" id="fourier-k" value="3" min="1" max="8">
            <small class="text-muted">Higher K fits more seasonality detail.</small>
        </div>

        <div class="form-check">
            <input class="form-check-input model-checkbox" type="checkbox" id="model-ridge" value="ridge">
            <label class="form-check-label" for="model-ridge">ML: Ridge Lag Regression</label>
        </div>
        <div id="params-ridge" class="param-group">
            <label class="form-label small">Lag Count (L)</label>
            <input type="number" class="form-control form-control-sm mb-2" id="ridge-lags" value="8" min="1" max="20">
            <div class="form-check mb-2">
                <input class="form-check-input" type="checkbox" id="ridge-seasonal" checked>
                <label class="form-check-label small" for="ridge-seasonal">Include 52-week lag</label>
            </div>
            <label class="form-label small">Rolling Mean Window</label>
            <input type="number" class="form-control form-control-sm mb-2" id="ridge-roll" value="4" min="0" max="12">
            <div class="form-check mb-2">
                <input class="form-check-input" type="checkbox" id="ridge-trend" checked>
                <label class="form-check-label small" for="ridge-trend">Include trend feature</label>
            </div>
            <label class="form-label small">Ridge Lambda</label>
            <input type="number" class="form-control form-control-sm" id="ridge-lambda" value="1" min="0" step="0.1">
        </div>

        <div class="form-check">
            <input class="form-check-input model-checkbox" type="checkbox" id="model-knn" value="knn">
            <label class="form-check-label" for="model-knn">ML: KNN Lag Regression</label>
        </div>
        <div id="params-knn" class="param-group">
            <label class="form-label small">Lag Count (L)</label>
            <input type="number" class="form-control form-control-sm mb-2" id="knn-lags" value="8" min="1" max="20">
            <div class="form-check mb-2">
                <input class="form-check-input" type="checkbox" id="knn-seasonal" checked>
                <label class="form-check-label small" for="knn-seasonal">Include 52-week lag</label>
            </div>
            <label class="form-label small">Neighbors (K)</label>
            <input type="number" class="form-control form-control-sm mb-2" id="knn-k" value="5" min="1" max="30">
            <div class="form-check">
                <input class="form-check-input" type="checkbox" id="knn-weighted" checked>
                <label class="form-check-label small" for="knn-weighted">Distance-weighted average</label>
            </div>
        </div>

        <div class="form-check">
            <input class="form-check-input model-checkbox" type="checkbox" id="model-snaive" value="snaive">
            <label class="form-check-label" for="model-snaive">Seasonal Naive (Benchmark)</label>
        </div>
        <div id="params-snaive" class="param-group">
            <small class="text-muted">Uses last year’s same-week value as the forecast.</small>
        </div>
    </div>

    <!-- Baseline Comparison -->
    <div class="mb-4">
        <label class="form-label fw-bold">6. Baseline Comparison</label>
        <div class="form-check mb-2">
            <input class="form-check-input" type="checkbox" id="baselineToggle">
            <label class="form-check-label" for="baselineToggle">Overlay baseline forecast</label>
        </div>
        <div id="baselineParams" class="param-group">
            <label class="form-label small">Rate (Multiplier)</label>
            <input type="number" class="form-control form-control-sm mb-1" id="baselineRate" value="1.05" step="0.01" min="0">
            <small class="text-muted">Baseline = rate × last 52 weeks</small>
        </div>
    </div>

    <button class="btn btn-primary w-100" id="btnRun">Run 52-Week Forecast</button>
    <div class="mt-2">
        <a class="btn btn-outline-secondary btn-sm w-100" href="../index.html">Back to Home Page</a>
    </div>
</div>

<!-- Main Content -->
<div class="main-content">
    <div class="container-fluid">
        <div class="row mb-4">
            <div class="col-12">
                <h2 class="fw-bold">Performance Dashboard</h2>
                <p class="text-muted">
                    Forecast the next 52 weeks based on historical weekly data. History and forecast are clearly separated on the x‑axis.
                </p>
            </div>
        </div>

        <!-- Chart Row -->
        <div class="card shadow-sm mb-4">
            <div class="card-body">
                <div id="chartContainer" style="width:100%; height:500px;"></div>
            </div>
        </div>

        <!-- Model Comparison -->
        <div class="card shadow-sm mb-4">
            <div class="card-header bg-white fw-bold">
                Model Comparison (52‑Week Forecast)
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-sm align-middle">
                        <thead>
                            <tr>
                                <th>Model</th>
                                <th>MAE</th>
                                <th>MAPE</th>
                                <th>RMSE</th>
                                <th>Notes</th>
                            </tr>
                        </thead>
                        <tbody id="metricsTableBody">
                            <tr><td colspan="5" class="text-muted">Run forecast to view results.</td></tr>
                        </tbody>
                    </table>
                </div>
                <div class="small-note" id="metricsNote">Metrics are reported only when a full 52‑week holdout exists.</div>
            </div>
        </div>

        <!-- Logs / Details -->
        <div class="card shadow-sm">
            <div class="card-header bg-white fw-bold">
                Forecast Details
            </div>
            <div class="card-body">
                <p><strong>Methodology:</strong> Train on weekly data and forecast the next 52 weeks.</p>
                <p>
                    In <strong>Forecast + Validation</strong> mode, the model is trained on the selected weekly window
                    and forecasts the next 52 weeks. Metrics are calculated only if at least 52 weeks remain in the dataset.
                </p>
                <div class="alert alert-info" id="statusMsg">
                    Ready to forecast.
                </div>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * ------------------------------------------------------------------
 * 1. STATE MANAGEMENT & CONSTANTS
 * ------------------------------------------------------------------
 */
const HORIZON = 52;
const SEASON = 52;
const DAY_MS = 24 * 60 * 60 * 1000;
const WEEK_MS = 7 * DAY_MS;

const MODEL_INFO = {
    hw: { name: 'Holt-Winters (Additive, 52w)', color: '#0d6efd' },
    fourier: { name: 'Seasonal Trend Regression (Fourier)', color: '#6f42c1' },
    ridge: { name: 'ML: Ridge Lag Regression', color: '#fd7e14' },
    knn: { name: 'ML: KNN Lag Regression', color: '#20c997' },
    snaive: { name: 'Seasonal Naive (Benchmark)', color: '#198754' }
};

const state = {
    weeklyData: [],
    weeklyLabels: [],
    weeklyDates: [],
    hasDates: true,
    trainStart: 0,
    trainEnd: 0,
    mode: 'validate',

    rawRows: [],
    colNames: [],
    hasHeader: false,

    modelForecasts: {},
    modelMetrics: {},
    modelNotes: {},

    baselineForecast: [],
    baselineMetrics: null
};

/**
 * ------------------------------------------------------------------
 * 2. UTILS
 * ------------------------------------------------------------------
 */
function formatDate(d) {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${y}-${m}-${day}`;
}

function addWeeks(date, weeks) {
    const d = new Date(date);
    d.setDate(d.getDate() + weeks * 7);
    return d;
}

function getWeekStartSunday(date) {
    const d = new Date(date);
    d.setHours(0,0,0,0);
    const day = d.getDay(); // 0 = Sunday
    d.setDate(d.getDate() - day);
    return d;
}

function generateNormalRandom(mean, std) {
    let u = 0, v = 0;
    while(u === 0) u = Math.random();
    while(v === 0) v = Math.random();
    const num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    return num * std + mean;
}

function parseNumeric(val) {
    if (typeof val === 'number' && !isNaN(val)) return val;
    if (typeof val === 'string') {
        const n = Number(val);
        if (!isNaN(n)) return n;
    }
    return null;
}

function parseDateValue(val) {
    if (val instanceof Date) {
        return isNaN(val) ? null : val;
    }
    if (typeof val === 'string') {
        const s = val.trim();
        if (!s) return null;

        // ISO date-only: YYYY-MM-DD
        let m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if (m) return new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]));

        // YYYY/MM/DD or YYYY.MM.DD
        m = s.match(/^(\d{4})[\/\.](\d{1,2})[\/\.](\d{1,2})$/);
        if (m) return new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]));

        // D/M/YYYY or M/D/YYYY (unambiguous)
        m = s.match(/^(\d{1,2})[\/\.](\d{1,2})[\/\.](\d{4})$/);
        if (m) {
            const a = Number(m[1]);
            const b = Number(m[2]);
            const y = Number(m[3]);
            if (a > 12 && b <= 12) return new Date(y, b - 1, a);
            if (b > 12 && a <= 12) return new Date(y, a - 1, b);
        }

        const d = new Date(s);
        if (!isNaN(d)) return d;
    }
    if (typeof val === 'number' && isFinite(val)) {
        const intVal = Math.trunc(val);

        // YYYYMMDD
        if (intVal === val && intVal >= 19000101 && intVal <= 21001231) {
            const s = String(intVal);
            if (s.length === 8) {
                const y = Number(s.slice(0,4));
                const m = Number(s.slice(4,6));
                const d = Number(s.slice(6,8));
                return new Date(y, m - 1, d);
            }
        }

        // Excel date serial
        if (val > 20000 && val < 60000) {
            const ms = (val - 25569) * 86400 * 1000;
            const utc = new Date(ms);
            return new Date(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate());
        }

        // Unix timestamp (ms or seconds)
        if (val > 1e12) {
            const d = new Date(val);
            if (!isNaN(d)) return d;
        }
        if (val > 1e9) {
            const d = new Date(val * 1000);
            if (!isNaN(d)) return d;
        }
    }
    return null;
}

function isLikelyHeader(row) {
    let hasDate = false;
    let hasNumber = false;
    for (let cell of row) {
        if (parseDateValue(cell)) hasDate = true;
        if (parseNumeric(cell) !== null) hasNumber = true;
    }
    return !hasDate && !hasNumber;
}

function detectDateColumn(rows) {
    const sample = rows.slice(0, Math.min(rows.length, 20));
    const colCount = Math.max(...sample.map(r => r.length));
    let bestIdx = -1;
    let bestCount = 0;
    for (let c = 0; c < colCount; c++) {
        let count = 0;
        for (let r = 0; r < sample.length; r++) {
            if (parseDateValue(sample[r][c])) count++;
        }
        if (count > bestCount) {
            bestCount = count;
            bestIdx = c;
        }
    }
    if (bestCount >= Math.max(3, Math.floor(sample.length * 0.6))) return bestIdx;
    return -1;
}

function detectNumericColumn(rows, excludeIdx) {
    const sample = rows.slice(0, Math.min(rows.length, 50));
    const colCount = Math.max(...sample.map(r => r.length));
    let best = { idx: -1, count: 0, variance: 0 };
    for (let c = 0; c < colCount; c++) {
        if (c === excludeIdx) continue;
        const nums = [];
        for (let r = 0; r < sample.length; r++) {
            const v = parseNumeric(sample[r][c]);
            if (v !== null) nums.push(v);
        }
        if (nums.length === 0) continue;
        const mean = nums.reduce((a,b)=>a+b,0) / nums.length;
        const variance = nums.reduce((a,b)=>a + Math.pow(b-mean,2),0) / nums.length;
        if (nums.length > best.count || (nums.length === best.count && variance > best.variance)) {
            best = { idx: c, count: nums.length, variance };
        }
    }
    return best.idx;
}

function labelForIndex(i) {
    if (i < state.weeklyLabels.length) return state.weeklyLabels[i];
    if (state.hasDates && state.weeklyDates.length > 0) {
        const lastDate = state.weeklyDates[state.weeklyDates.length - 1];
        const weeksAhead = i - (state.weeklyDates.length - 1);
        return formatDate(addWeeks(lastDate, weeksAhead));
    }
    return `W${i + 1}`;
}

function calculateMetrics(actual, forecast) {
    const n = Math.min(actual.length, forecast.length);
    if (n === 0) return { mae: '-', mape: '-', rmse: '-' };

    let sumAbsError = 0;
    let sumAbsPercError = 0;
    let sumSqError = 0;
    let denomCount = 0;

    for (let i = 0; i < n; i++) {
        const a = actual[i];
        const f = forecast[i];
        const err = a - f;
        sumAbsError += Math.abs(err);
        sumSqError += err * err;
        if (a !== 0) {
            sumAbsPercError += Math.abs(err / a);
            denomCount++;
        }
    }

    return {
        mae: (sumAbsError / n).toFixed(2),
        mape: denomCount === 0 ? '-' : ((sumAbsPercError / denomCount) * 100).toFixed(2) + '%',
        rmse: Math.sqrt(sumSqError / n).toFixed(2)
    };
}

function setStatus(msg, type='info') {
    const el = document.getElementById('statusMsg');
    el.className = `alert alert-${type}`;
    el.innerText = msg;
}

function getSelectedModels() {
    return Array.from(document.querySelectorAll('.model-checkbox'))
        .filter(chk => chk.checked)
        .map(chk => chk.value);
}

function modelDisplayName(key) {
    return MODEL_INFO[key] ? MODEL_INFO[key].name : key;
}

function updateModelSelectionState() {
    const selected = getSelectedModels();
    document.getElementById('btnRun').disabled = selected.length === 0;
}

/**
 * ------------------------------------------------------------------
 * 3. DEMO DATA (WEEKLY)
 * ------------------------------------------------------------------
 */
function generateDemoWeeklyData() {
    const n = 156; // 3 years weekly
    const data = [];
    const labels = [];
    const dates = [];

    const today = new Date();
    const lastSunday = getWeekStartSunday(today);
    const start = addWeeks(lastSunday, -(n - 1));

    for (let t = 0; t < n; t++) {
        const trend = 0.6 * t;
        const seasonality = 20 * Math.sin((2 * Math.PI * t) / SEASON);
        const noise = generateNormalRandom(0, 10);
        const base = 100;

        let val = Math.round(base + trend + seasonality + noise);
        if (val < 0) val = 0;

        const d = addWeeks(start, t);
        data.push(val);
        dates.push(d);
        labels.push(formatDate(d));
    }
    return { data, labels, dates };
}

/**
 * ------------------------------------------------------------------
 * 4. COLUMN SELECTION & TRANSFORM
 * ------------------------------------------------------------------
 */
function updateColumnHint() {
    if (!state.rawRows || state.rawRows.length === 0) return;
    const dIdx = detectDateColumn(state.rawRows);
    const vIdx = detectNumericColumn(state.rawRows, dIdx);
    const dName = dIdx !== -1 ? state.colNames[dIdx] : 'Not found';
    const vName = vIdx !== -1 ? state.colNames[vIdx] : 'Not found';
    document.getElementById('columnHint').innerText =
        `Auto-detect suggests Date: ${dName} | Demand: ${vName}. You can override below.`;
}

function setupColumnSelection(headers, rows) {
    const section = document.getElementById('columnSelectionSection');
    section.style.display = 'block';

    const dateSelect = document.getElementById('dateColSelect');
    const valueSelect = document.getElementById('valueColSelect');

    const colOptions = headers.map((h, i) => ({ value: String(i), label: h }));

    dateSelect.innerHTML = '';
    dateSelect.append(new Option('Auto-detect', 'auto'));
    dateSelect.append(new Option('No date column (already weekly)', 'none'));
    colOptions.forEach(opt => dateSelect.append(new Option(opt.label, opt.value)));

    valueSelect.innerHTML = '';
    valueSelect.append(new Option('Auto-detect', 'auto'));
    colOptions.forEach(opt => valueSelect.append(new Option(opt.label, opt.value)));

    updateColumnHint();
    renderPreviewTable(headers, rows.slice(0, 5));
}

function renderPreviewTable(headers, rows) {
    const headRow = document.getElementById('previewHead');
    const body = document.getElementById('previewBody');

    headRow.innerHTML = '';
    body.innerHTML = '';

    const colCount = headers.length;
    headers.forEach(h => {
        const th = document.createElement('th');
        th.textContent = h;
        headRow.appendChild(th);
    });

    rows.forEach(r => {
        const tr = document.createElement('tr');
        for (let i = 0; i < colCount; i++) {
            const td = document.createElement('td');
            td.textContent = r[i] !== undefined ? r[i] : '';
            tr.appendChild(td);
        }
        body.appendChild(tr);
    });
}

function transformRowsToWeekly(rows, options = {}) {
    const { dateMode = 'auto', dateIdx = null, valueMode = 'auto', valueIdx = null } = options;

    if (!rows || rows.length === 0) {
        return { data: [], labels: [], dates: [], hasDates: false, error: true, message: 'No data found.' };
    }

    let dIdx = -1;
    if (dateMode === 'auto') dIdx = detectDateColumn(rows);
    if (dateMode === 'manual') dIdx = dateIdx;

    let vIdx = -1;
    if (valueMode === 'auto') vIdx = detectNumericColumn(rows, dIdx);
    if (valueMode === 'manual') vIdx = valueIdx;

    // Weekly series (no date)
    if (dateMode === 'none' || dIdx === -1) {
        if (dateMode === 'manual') {
            return { data: [], labels: [], dates: [], hasDates: false, error: true,
                message: 'Selected date column has no parsable dates.' };
        }

        if (vIdx === -1) {
            return { data: [], labels: [], dates: [], hasDates: false, error: true,
                message: 'Demand column not detected. Please select a numeric column.' };
        }

        const data = [];
        rows.forEach(row => {
            const v = parseNumeric(row[vIdx]);
            if (v !== null) data.push(Math.max(0, v));
        });

        if (data.length === 0) {
            return { data: [], labels: [], dates: [], hasDates: false, error: true,
                message: 'No numeric values found in the selected demand column.' };
        }

        const labels = data.map((_, i) => `W${i + 1}`);
        return {
            data, labels, dates: [], hasDates: false,
            error: false,
            message: `Loaded ${data.length} rows as weekly series (no date column detected).`
        };
    }

    // Date-based aggregation (daily -> weekly)
    if (vIdx === -1) {
        return { data: [], labels: [], dates: [], hasDates: false, error: true,
            message: 'Demand column not detected. Please select a numeric column.' };
    }

    const map = new Map();
    let validCount = 0;

    for (let row of rows) {
        const d = parseDateValue(row[dIdx]);
        let v = parseNumeric(row[vIdx]);
        if (!d || v === null) continue;
        validCount++;
        v = Math.max(0, v);

        const wk = getWeekStartSunday(d);
        const t = wk.getTime();
        map.set(t, (map.get(t) || 0) + v);
    }

    if (validCount === 0) {
        return {
            data: [], labels: [], dates: [], hasDates: false, error: true,
            message: 'No valid date + demand rows found. Please check selected columns.'
        };
    }

    const times = Array.from(map.keys()).sort((a,b)=>a-b);
    const minDate = new Date(times[0]);
    const maxDate = new Date(times[times.length - 1]);

    const data = [];
    const labels = [];
    const dates = [];

    for (let d = new Date(minDate); d.getTime() <= maxDate.getTime(); d.setDate(d.getDate() + 7)) {
        const t = d.getTime();
        const val = map.get(t) || 0;
        data.push(val);
        dates.push(new Date(d));
        labels.push(formatDate(d));
    }

    return {
        data, labels, dates, hasDates: true, error: false,
        message: `Aggregated ${rows.length} rows into ${data.length} weekly sums (Sun–Sat). Missing weeks filled with 0.`
    };
}

/**
 * ------------------------------------------------------------------
 * 5. FORECASTING METHODS
 * ------------------------------------------------------------------
 */
function forecastSeasonalNaive(history, horizon=HORIZON, season=SEASON) {
    const n = history.length;
    const fc = [];
    if (n >= season) {
        for (let i = 0; i < horizon; i++) {
            fc.push(history[n - season + (i % season)]);
        }
    } else {
        const last = n > 0 ? history[n - 1] : 0;
        for (let i = 0; i < horizon; i++) fc.push(last);
    }
    return fc;
}

function forecastBaselineRate(history, horizon=HORIZON, season=SEASON, rate=1.05) {
    const n = history.length;
    const fc = [];
    if (n >= season) {
        for (let i = 0; i < horizon; i++) {
            fc.push(history[n - season + i] * rate);
        }
    } else {
        const last = n > 0 ? history[n - 1] : 0;
        for (let i = 0; i < horizon; i++) fc.push(last * rate);
    }
    return fc;
}

function initialTrend(data, seasonLength) {
    if (data.length >= 2 * seasonLength) {
        const sum1 = data.slice(0, seasonLength).reduce((a,b)=>a+b,0) / seasonLength;
        const sum2 = data.slice(seasonLength, 2*seasonLength).reduce((a,b)=>a+b,0) / seasonLength;
        return (sum2 - sum1) / seasonLength;
    }
    return (data[data.length - 1] - data[0]) / Math.max(1, data.length - 1);
}

function initialSeasonals(data, seasonLength) {
    const seasonals = new Array(seasonLength).fill(0);
    const seasonCount = Math.floor(data.length / seasonLength);
    if (seasonCount < 2) {
        const avg = data.reduce((a,b)=>a+b,0) / data.length;
        for (let i = 0; i < seasonLength; i++) {
            seasonals[i] = (data[i] !== undefined ? data[i] : avg) - avg;
        }
        return seasonals;
    }
    const seasonAverages = [];
    for (let j = 0; j < seasonCount; j++) {
        const start = j * seasonLength;
        const seasonAvg = data.slice(start, start + seasonLength).reduce((a,b)=>a+b,0) / seasonLength;
        seasonAverages.push(seasonAvg);
    }
    for (let i = 0; i < seasonLength; i++) {
        let sum = 0;
        for (let j = 0; j < seasonCount; j++) {
            sum += data[j * seasonLength + i] - seasonAverages[j];
        }
        seasonals[i] = sum / seasonCount;
    }
    return seasonals;
}

function forecastHoltWintersAdditive(history, alpha, beta, gamma, horizon=HORIZON, seasonLength=SEASON) {
    const n = history.length;
    let level = history[0];
    let trend = initialTrend(history, seasonLength);
    const seasonals = initialSeasonals(history, seasonLength);

    for (let i = 0; i < n; i++) {
        const val = history[i];
        const idx = i % seasonLength;
        const lastLevel = level;
        const seasonal = seasonals[idx];

        level = alpha * (val - seasonal) + (1 - alpha) * (level + trend);
        trend = beta * (level - lastLevel) + (1 - beta) * trend;
        seasonals[idx] = gamma * (val - level) + (1 - gamma) * seasonal;
    }

    const fc = [];
    for (let h = 1; h <= horizon; h++) {
        const idx = (n + h - 1) % seasonLength;
        fc.push(level + h * trend + seasonals[idx]);
    }
    return fc;
}

function flattenVector(vec) {
    if (!Array.isArray(vec)) return [];
    return vec.map(v => Array.isArray(v) ? v[0] : v);
}

function forecastFourierTrend(history, K=3, horizon=HORIZON, seasonLength=SEASON) {
    const n = history.length;
    const X = [];
    const y = history;

    for (let t = 0; t < n; t++) {
        const row = [1, t];
        for (let k = 1; k <= K; k++) {
            row.push(Math.sin(2 * Math.PI * k * t / seasonLength));
            row.push(Math.cos(2 * Math.PI * k * t / seasonLength));
        }
        X.push(row);
    }

    try {
        const X_mat = math.matrix(X);
        const Y_mat = math.matrix(y);
        const Xt = math.transpose(X_mat);
        const XtX = math.multiply(Xt, X_mat);

        const lambda = 1e-6;
        const I = math.identity(XtX.size()[0]);
        const XtX_reg = math.add(XtX, math.multiply(lambda, I));

        const XtX_inv = math.inv(XtX_reg);
        const XtY = math.multiply(Xt, Y_mat);
        const Beta = flattenVector(math.multiply(XtX_inv, XtY).toArray());

        const fc = [];
        for (let h = 0; h < horizon; h++) {
            const t = n + h;
            const row = [1, t];
            for (let k = 1; k <= K; k++) {
                row.push(Math.sin(2 * Math.PI * k * t / seasonLength));
                row.push(Math.cos(2 * Math.PI * k * t / seasonLength));
            }
            let pred = 0;
            for (let i = 0; i < row.length; i++) pred += row[i] * Beta[i];
            fc.push(pred);
        }
        return fc;
    } catch (e) {
        console.warn('Fourier regression failed:', e);
        return null;
    }
}

/**
 * ML: Lag Feature Builders
 */
function buildFeatureVector(series, t, opts) {
    const f = [];
    if (opts.includeTrend) f.push(t / 100);
    for (let i = 1; i <= opts.lagCount; i++) {
        f.push(series[t - i]);
    }
    if (opts.includeSeasonal) {
        f.push(series[t - opts.seasonalLag]);
    }
    if (opts.rollingWindow > 0) {
        let sum = 0;
        for (let i = t - opts.rollingWindow; i < t; i++) sum += series[i];
        f.push(sum / opts.rollingWindow);
    }
    return f;
}

function buildLaggedDataset(series, opts) {
    const maxLag = Math.max(
        opts.lagCount,
        opts.includeSeasonal ? opts.seasonalLag : 0,
        opts.rollingWindow
    );
    const X = [];
    const y = [];
    for (let t = maxLag; t < series.length; t++) {
        X.push(buildFeatureVector(series, t, opts));
        y.push(series[t]);
    }
    return { X, y, maxLag };
}

function ridgeFit(X, y, lambda) {
    try {
        const Xb = X.map(row => [1, ...row]);
        const X_mat = math.matrix(Xb);
        const Y_mat = math.matrix(y);
        const Xt = math.transpose(X_mat);
        const XtX = math.multiply(Xt, X_mat);

        const I = math.identity(XtX.size()[0]);
        const XtX_reg = math.add(XtX, math.multiply(lambda, I));

        const XtX_inv = math.inv(XtX_reg);
        const XtY = math.multiply(Xt, Y_mat);
        return flattenVector(math.multiply(XtX_inv, XtY).toArray());
    } catch (e) {
        console.warn('Ridge fit failed:', e);
        return null;
    }
}

function ridgeForecast(history, opts, horizon=HORIZON) {
    const ds = buildLaggedDataset(history, opts);
    if (ds.X.length < 2) return null;

    const beta = ridgeFit(ds.X, ds.y, opts.lambda);
    if (!beta) return null;

    const temp = history.slice();
    const fc = [];
    for (let h = 0; h < horizon; h++) {
        const t = temp.length;
        const feat = buildFeatureVector(temp, t, opts);
        const row = [1, ...feat];
        let pred = 0;
        for (let i = 0; i < row.length; i++) pred += row[i] * beta[i];
        fc.push(pred);
        temp.push(pred);
    }
    return fc;
}

function standardizeMatrix(X) {
    const n = X.length;
    const m = X[0].length;
    const mean = new Array(m).fill(0);
    const std = new Array(m).fill(0);

    for (let j = 0; j < m; j++) {
        for (let i = 0; i < n; i++) mean[j] += X[i][j];
        mean[j] /= n;
        for (let i = 0; i < n; i++) std[j] += Math.pow(X[i][j] - mean[j], 2);
        std[j] = Math.sqrt(std[j] / n) || 1;
    }

    const Xs = X.map(row => row.map((v, j) => (v - mean[j]) / std[j]));
    return { Xs, mean, std };
}

function standardizeVector(vec, mean, std) {
    return vec.map((v, j) => (v - mean[j]) / std[j]);
}

function knnForecast(history, opts, horizon=HORIZON) {
    const ds = buildLaggedDataset(history, opts);
    if (ds.X.length < 2) return null;

    const { Xs, mean, std } = standardizeMatrix(ds.X);
    const y = ds.y;
    const k = Math.max(1, Math.min(opts.k, y.length));

    const temp = history.slice();
    const fc = [];

    for (let h = 0; h < horizon; h++) {
        const t = temp.length;
        let feat = buildFeatureVector(temp, t, opts);
        feat = standardizeVector(feat, mean, std);

        const dists = Xs.map((row, i) => {
            let sum = 0;
            for (let j = 0; j < row.length; j++) {
                const diff = row[j] - feat[j];
                sum += diff * diff;
            }
            return { i, d: Math.sqrt(sum) };
        });

        dists.sort((a,b) => a.d - b.d);
        const neighbors = dists.slice(0, k);

        let pred = 0;
        if (opts.weighted) {
            let wsum = 0;
            neighbors.forEach(n => {
                const w = 1 / (n.d + 1e-6);
                pred += w * y[n.i];
                wsum += w;
            });
            pred = wsum === 0 ? y[neighbors[0].i] : pred / wsum;
        } else {
            neighbors.forEach(n => pred += y[n.i]);
            pred /= k;
        }

        fc.push(pred);
        temp.push(pred);
    }

    return fc;
}

/**
 * ------------------------------------------------------------------
 * 6. MAIN LOGIC & UI HANDLING
 * ------------------------------------------------------------------
 */
function updateTrainingControls() {
    const n = state.weeklyData.length;
    const startSlider = document.getElementById('trainStart');
    const endSlider = document.getElementById('trainEnd');

    if (state.mode === 'forecast') {
        state.trainStart = 0;
        state.trainEnd = Math.max(0, n - 1);
        startSlider.disabled = true;
        endSlider.disabled = true;
        document.getElementById('trainingWindowSection').classList.add('opacity-50');
    } else {
        startSlider.disabled = false;
        endSlider.disabled = false;
        document.getElementById('trainingWindowSection').classList.remove('opacity-50');
        if (state.trainEnd > n - 1) state.trainEnd = Math.max(0, n - 1);
        if (state.trainStart >= state.trainEnd) state.trainStart = Math.max(0, state.trainEnd - 1);
    }

    startSlider.max = Math.max(0, state.trainEnd - 1);
    endSlider.max = Math.max(0, n - 1);

    startSlider.value = state.trainStart;
    endSlider.value = state.trainEnd;

    updateTrainingLabels();
}

function updateTrainingLabels() {
    document.getElementById('trainStartLabel').innerText = labelForIndex(state.trainStart);
    document.getElementById('trainEndLabel').innerText = labelForIndex(state.trainEnd);

    const holdout = Math.max(0, state.weeklyData.length - (state.trainEnd + 1));
    document.getElementById('holdoutAvail').innerText = holdout;
}

function init() {
    const demo = generateDemoWeeklyData();
    state.weeklyData = demo.data;
    state.weeklyLabels = demo.labels;
    state.weeklyDates = demo.dates;
    state.hasDates = true;

    const n = state.weeklyData.length;
    state.trainStart = 0;
    state.trainEnd = n > HORIZON ? n - HORIZON - 1 : n - 1;
    state.mode = 'validate';

    state.modelForecasts = {};
    state.modelMetrics = {};
    state.modelNotes = {};
    state.baselineForecast = [];
    state.baselineMetrics = null;

    document.getElementById('modeValidate').checked = true;
    document.getElementById('modeForecast').checked = false;

    document.querySelectorAll('.param-group').forEach(el => el.style.display = 'none');
    document.getElementById('params-hw').style.display = 'block';
    document.getElementById('params-fourier').style.display = 'block';

    document.getElementById('baselineToggle').checked = false;
    document.getElementById('baselineParams').style.display = 'none';

    updateTrainingControls();
    updateModelSelectionState();
    renderChart();
    setStatus('Ready to forecast (demo data loaded).', 'info');
}

function runForecastLogic() {
    const selected = getSelectedModels();
    if (selected.length === 0) {
        setStatus('Please select at least one model.', 'warning');
        return;
    }

    const n = state.weeklyData.length;
    if (n < 2) {
        setStatus('Not enough data to forecast.', 'warning');
        return;
    }

    const trainSeries = state.weeklyData.slice(state.trainStart, state.trainEnd + 1);
    if (trainSeries.length < 2) {
        setStatus('Training window is too small. Please extend it.', 'warning');
        return;
    }

    const warnings = [];
    state.modelForecasts = {};
    state.modelNotes = {};

    selected.forEach(modelKey => {
        let fc = null;
        let note = 'OK';

        if (modelKey === 'hw') {
            const alpha = parseFloat(document.getElementById('hw-alpha').value);
            const beta = parseFloat(document.getElementById('hw-beta').value);
            const gamma = parseFloat(document.getElementById('hw-gamma').value);

            if (trainSeries.length < SEASON * 2) {
                note = 'Fallback to Seasonal Naive (need 104+ weeks).';
                warnings.push(`${modelDisplayName(modelKey)}: ${note}`);
                fc = forecastSeasonalNaive(trainSeries);
            } else {
                fc = forecastHoltWintersAdditive(trainSeries, alpha, beta, gamma);
            }
        }

        if (modelKey === 'fourier') {
            const K = parseInt(document.getElementById('fourier-k').value, 10);
            if (trainSeries.length < SEASON) {
                note = 'Fallback to Seasonal Naive (need 52+ weeks).';
                warnings.push(`${modelDisplayName(modelKey)}: ${note}`);
                fc = forecastSeasonalNaive(trainSeries);
            } else {
                fc = forecastFourierTrend(trainSeries, K);
                if (!fc) {
                    note = 'Fallback to Seasonal Naive (regression failed).';
                    warnings.push(`${modelDisplayName(modelKey)}: ${note}`);
                    fc = forecastSeasonalNaive(trainSeries);
                }
            }
        }

        if (modelKey === 'ridge') {
            const opts = {
                lagCount: parseInt(document.getElementById('ridge-lags').value, 10),
                includeSeasonal: document.getElementById('ridge-seasonal').checked,
                seasonalLag: SEASON,
                rollingWindow: parseInt(document.getElementById('ridge-roll').value, 10),
                includeTrend: document.getElementById('ridge-trend').checked,
                lambda: parseFloat(document.getElementById('ridge-lambda').value)
            };
            const maxLag = Math.max(opts.lagCount, opts.includeSeasonal ? SEASON : 0, opts.rollingWindow);
            if (trainSeries.length <= maxLag + 1) {
                note = `Fallback to Seasonal Naive (need > ${maxLag + 1} weeks).`;
                warnings.push(`${modelDisplayName(modelKey)}: ${note}`);
                fc = forecastSeasonalNaive(trainSeries);
            } else {
                fc = ridgeForecast(trainSeries, opts);
                if (!fc) {
                    note = 'Fallback to Seasonal Naive (ridge failed).';
                    warnings.push(`${modelDisplayName(modelKey)}: ${note}`);
                    fc = forecastSeasonalNaive(trainSeries);
                }
            }
        }

        if (modelKey === 'knn') {
            const opts = {
                lagCount: parseInt(document.getElementById('knn-lags').value, 10),
                includeSeasonal: document.getElementById('knn-seasonal').checked,
                seasonalLag: SEASON,
                rollingWindow: 0,
                includeTrend: false,
                k: parseInt(document.getElementById('knn-k').value, 10),
                weighted: document.getElementById('knn-weighted').checked
            };
            const maxLag = Math.max(opts.lagCount, opts.includeSeasonal ? SEASON : 0);
            if (trainSeries.length <= maxLag + 1) {
                note = `Fallback to Seasonal Naive (need > ${maxLag + 1} weeks).`;
                warnings.push(`${modelDisplayName(modelKey)}: ${note}`);
                fc = forecastSeasonalNaive(trainSeries);
            } else {
                fc = knnForecast(trainSeries, opts);
                if (!fc) {
                    note = 'Fallback to Seasonal Naive (KNN failed).';
                    warnings.push(`${modelDisplayName(modelKey)}: ${note}`);
                    fc = forecastSeasonalNaive(trainSeries);
                }
            }
        }

        if (modelKey === 'snaive') {
            fc = forecastSeasonalNaive(trainSeries);
            if (trainSeries.length < SEASON) {
                note = 'Used last value (insufficient 52-week history).';
                warnings.push(`${modelDisplayName(modelKey)}: ${note}`);
            }
        }

        fc = fc.map(v => Math.max(0, v));
        state.modelForecasts[modelKey] = fc;
        state.modelNotes[modelKey] = note;
    });

    // Baseline
    const baselineEnabled = document.getElementById('baselineToggle').checked;
    if (baselineEnabled) {
        const rate = parseFloat(document.getElementById('baselineRate').value);
        let baseline = forecastBaselineRate(trainSeries, HORIZON, SEASON, rate);
        if (trainSeries.length < SEASON) {
            warnings.push('Baseline: Used last value (insufficient 52-week history).');
        }
        baseline = baseline.map(v => Math.max(0, v));
        state.baselineForecast = baseline;
    } else {
        state.baselineForecast = [];
    }

    // Metrics
    state.modelMetrics = {};
    state.baselineMetrics = null;

    if (state.mode === 'validate') {
        const holdoutStart = state.trainEnd + 1;
        const holdoutEnd = state.trainEnd + HORIZON;
        const holdoutAvailable = n - holdoutStart;

        if (holdoutAvailable >= HORIZON) {
            const actuals = state.weeklyData.slice(holdoutStart, holdoutEnd + 1);
            selected.forEach(key => {
                state.modelMetrics[key] = calculateMetrics(actuals, state.modelForecasts[key]);
            });
            if (baselineEnabled) {
                state.baselineMetrics = calculateMetrics(actuals, state.baselineForecast);
            }
            setStatus('Forecast complete. Metrics computed on 52-week holdout.', 'success');
        } else {
            setStatus(`Forecast complete, but holdout is insufficient (${holdoutAvailable} weeks). Metrics not computed.`, 'warning');
        }
    } else {
        setStatus('Forecast complete (Pure Forecast mode).', 'success');
    }

    if (warnings.length > 0) {
        setStatus(warnings.join(' '), 'warning');
    }

    updateComparisonTable();
    renderChart();
}

function updateComparisonTable() {
    const tbody = document.getElementById('metricsTableBody');
    tbody.innerHTML = '';

    const selected = getSelectedModels();
    if (selected.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="text-muted">No models selected.</td></tr>';
        return;
    }

    selected.forEach(key => {
        const metrics = state.modelMetrics[key];
        const note = state.modelNotes[key] || 'OK';

        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td>${modelDisplayName(key)}</td>
            <td>${metrics ? metrics.mae : '-'}</td>
            <td>${metrics ? metrics.mape : '-'}</td>
            <td>${metrics ? metrics.rmse : '-'}</td>
            <td>${note}</td>
        `;
        tbody.appendChild(tr);
    });

    if (document.getElementById('baselineToggle').checked) {
        const rate = parseFloat(document.getElementById('baselineRate').value);
        const metrics = state.baselineMetrics;

        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td>Baseline (Rate × Last 52w, rate=${rate})</td>
            <td>${metrics ? metrics.mae : '-'}</td>
            <td>${metrics ? metrics.mape : '-'}</td>
            <td>${metrics ? metrics.rmse : '-'}</td>
            <td>Benchmark</td>
        `;
        tbody.appendChild(tr);
    }
}

function renderChart() {
    const n = state.weeklyData.length;
    if (n === 0) return;

    const forecastStartIdx = state.trainEnd + 1;
    const forecastEndIdx = state.trainEnd + HORIZON;

    const xTrain = [];
    const yTrain = [];

    for (let i = 0; i <= Math.min(state.trainEnd, n - 1); i++) {
        xTrain.push(labelForIndex(i));
        yTrain.push(state.weeklyData[i]);
    }

    let xHoldout = [];
    let yHoldout = [];
    if (state.mode === 'validate') {
        const holdoutEnd = Math.min(forecastEndIdx, n - 1);
        if (holdoutEnd >= forecastStartIdx) {
            for (let i = forecastStartIdx; i <= holdoutEnd; i++) {
                xHoldout.push(labelForIndex(i));
                yHoldout.push(state.weeklyData[i]);
            }
        }
    } else {
        xHoldout = [];
        yHoldout = [];
        for (let i = state.trainEnd + 1; i <= n - 1; i++) {
            xHoldout.push(labelForIndex(i));
            yHoldout.push(state.weeklyData[i]);
        }
    }

    const xForecast = [];
    for (let i = forecastStartIdx; i <= forecastEndIdx; i++) {
        xForecast.push(labelForIndex(i));
    }

    const traces = [];

    traces.push({
        x: xTrain,
        y: yTrain,
        type: 'scatter',
        mode: 'lines',
        name: 'Actual (History)',
        line: { color: '#adb5bd', width: 2 }
    });

    if (xHoldout.length > 0) {
        traces.push({
            x: xHoldout,
            y: yHoldout,
            type: 'scatter',
            mode: 'lines',
            name: state.mode === 'validate' ? 'Actual (Holdout)' : 'Actual (Recent)',
            line: { color: '#212529', width: 2 }
        });
    }

    const selected = getSelectedModels();
    selected.forEach(key => {
        const fc = state.modelForecasts[key];
        if (!fc || fc.length === 0) return;
        const style = {
            color: MODEL_INFO[key]?.color || '#0d6efd',
            width: 2
        };
        if (key === 'snaive') style.dash = 'dot';
        if (key === 'knn') style.dash = 'dash';

        traces.push({
            x: xForecast,
            y: fc,
            type: 'scatter',
            mode: 'lines',
            name: `Forecast - ${modelDisplayName(key)}`,
            line: style
        });
    });

    if (state.baselineForecast.length > 0) {
        traces.push({
            x: xForecast,
            y: state.baselineForecast,
            type: 'scatter',
            mode: 'lines',
            name: 'Baseline (Rate × Last 52w)',
            line: { color: '#dc3545', width: 2, dash: 'dashdot' }
        });
    }

    const yMax = Math.max(
        ...state.weeklyData,
        ...(selected.flatMap(k => state.modelForecasts[k] || [])),
        ...(state.baselineForecast.length ? state.baselineForecast : [0])
    ) * 1.1;

    const shapes = [];
    if (xForecast.length > 0) {
        shapes.push({
            type: 'rect',
            xref: 'x',
            yref: 'paper',
            x0: xForecast[0],
            x1: xForecast[xForecast.length - 1],
            y0: 0,
            y1: 1,
            fillcolor: 'rgba(13,110,253,0.06)',
            line: { width: 0 }
        });
        shapes.push({
            type: 'line',
            xref: 'x',
            yref: 'paper',
            x0: xForecast[0],
            x1: xForecast[0],
            y0: 0,
            y1: 1,
            line: { color: '#dc3545', width: 2, dash: 'dot' }
        });
    }

    const layout = {
        title: 'Weekly Demand: History vs 52-Week Forecast',
        xaxis: { title: 'Week' },
        yaxis: { title: 'Demand (Units)', range: [0, yMax] },
        shapes: shapes,
        annotations: xForecast.length ? [{
            x: xForecast[0],
            y: yMax,
            xref: 'x',
            yref: 'y',
            text: 'Forecast Start',
            showarrow: true,
            arrowhead: 7,
            ax: 0,
            ay: -40
        }] : [],
        margin: { t: 40, r: 20, l: 50, b: 40 }
    };

    Plotly.newPlot('chartContainer', traces, layout, { responsive: true });
}

/**
 * ------------------------------------------------------------------
 * 7. EVENT LISTENERS
 * ------------------------------------------------------------------
 */
document.getElementById('trainStart').addEventListener('input', (e) => {
    state.trainStart = parseInt(e.target.value, 10);
    if (state.trainStart >= state.trainEnd) {
        state.trainStart = Math.max(0, state.trainEnd - 1);
        e.target.value = state.trainStart;
    }
    updateTrainingLabels();
    renderChart();
});

document.getElementById('trainEnd').addEventListener('input', (e) => {
    state.trainEnd = parseInt(e.target.value, 10);
    if (state.trainEnd <= state.trainStart) {
        state.trainEnd = Math.min(state.weeklyData.length - 1, state.trainStart + 1);
        e.target.value = state.trainEnd;
    }
    updateTrainingControls();
    renderChart();
});

document.getElementById('baselineToggle').addEventListener('change', (e) => {
    document.getElementById('baselineParams').style.display = e.target.checked ? 'block' : 'none';
});

document.getElementById('modeValidate').addEventListener('change', (e) => {
    if (e.target.checked) {
        state.mode = 'validate';
        updateTrainingControls();
        renderChart();
    }
});

document.getElementById('modeForecast').addEventListener('change', (e) => {
    if (e.target.checked) {
        state.mode = 'forecast';
        updateTrainingControls();
        renderChart();
    }
});

document.getElementById('btnReset').addEventListener('click', () => {
    document.getElementById('csvUpload').value = '';
    document.getElementById('columnSelectionSection').style.display = 'none';
    init();
    setStatus('Reset complete. Ready.', 'info');
});

document.getElementById('csvUpload').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;

    Papa.parse(file, {
        dynamicTyping: true,
        skipEmptyLines: true,
        complete: function(results) {
            let rows = results.data || [];
            if (rows.length === 0) {
                setStatus('Empty CSV.', 'warning');
                return;
            }

            const hasHeader = isLikelyHeader(rows[0]);
            let headers = [];
            let dataRows = [];

            if (hasHeader) {
                headers = rows[0].map((v, i) => String(v || `Column ${i+1}`));
                dataRows = rows.slice(1);
            } else {
                const colCount = Math.max(...rows.map(r => r.length));
                headers = Array.from({length: colCount}, (_, i) => `Column ${i+1}`);
                dataRows = rows;
            }

            state.rawRows = dataRows;
            state.colNames = headers;
            state.hasHeader = hasHeader;

            setupColumnSelection(headers, dataRows);

            // default auto-detect and apply
            document.getElementById('dateColSelect').value = 'auto';
            document.getElementById('valueColSelect').value = 'auto';
            applyColumns();

            setStatus('CSV loaded. Review column selection if needed.', 'info');
        }
    });
});

function applyColumns() {
    if (!state.rawRows || state.rawRows.length === 0) {
        setStatus('No data to apply.', 'warning');
        return;
    }

    const dateVal = document.getElementById('dateColSelect').value;
    const valueVal = document.getElementById('valueColSelect').value;

    let dateMode = 'auto';
    let dateIdx = null;
    if (dateVal === 'none') dateMode = 'none';
    else if (dateVal !== 'auto') { dateMode = 'manual'; dateIdx = parseInt(dateVal, 10); }

    let valueMode = 'auto';
    let valueIdx = null;
    if (valueVal !== 'auto') { valueMode = 'manual'; valueIdx = parseInt(valueVal, 10); }

    const transformed = transformRowsToWeekly(state.rawRows, { dateMode, dateIdx, valueMode, valueIdx });

    if (transformed.error) {
        setStatus(transformed.message, 'danger');
        return;
    }

    if (transformed.data.length > 10) {
        state.weeklyData = transformed.data;
        state.weeklyLabels = transformed.labels;
        state.weeklyDates = transformed.dates;
        state.hasDates = transformed.hasDates;

        const n = state.weeklyData.length;
        state.trainStart = 0;
        state.trainEnd = n > HORIZON ? n - HORIZON - 1 : n - 1;

        updateTrainingControls();
        renderChart();
        updateModelSelectionState();

        setStatus(transformed.message, 'success');
    } else {
        setStatus('Dataset too small after transformation.', 'warning');
    }
}

document.getElementById('btnApplyColumns').addEventListener('click', applyColumns);

document.querySelectorAll('.model-checkbox').forEach(chk => {
    chk.addEventListener('change', (e) => {
        const key = e.target.value;
        const panel = document.getElementById(`params-${key}`);
        if (panel) panel.style.display = e.target.checked ? 'block' : 'none';
        updateModelSelectionState();
    });
});

document.getElementById('btnSelectAll').addEventListener('click', () => {
    document.querySelectorAll('.model-checkbox').forEach(chk => {
        chk.checked = true;
        const panel = document.getElementById(`params-${chk.value}`);
        if (panel) panel.style.display = 'block';
    });
    updateModelSelectionState();
});

document.getElementById('btnClearAll').addEventListener('click', () => {
    document.querySelectorAll('.model-checkbox').forEach(chk => {
        chk.checked = false;
        const panel = document.getElementById(`params-${chk.value}`);
        if (panel) panel.style.display = 'none';
    });
    updateModelSelectionState();
});

document.getElementById('btnRun').addEventListener('click', () => {
    document.getElementById('loadingSpinner').style.display = 'flex';
    setTimeout(() => {
        runForecastLogic();
        document.getElementById('loadingSpinner').style.display = 'none';
    }, 100);
});

/**
 * ------------------------------------------------------------------
 * 8. INIT
 * ------------------------------------------------------------------
 */
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('params-hw').style.display = 'block';
    document.getElementById('params-fourier').style.display = 'block';
    init();
});
</script>
</body>
</html>
